<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-rc/gc优化" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/gc优化/" class="article-date">
  <time datetime="2019-01-08T15:38:07.476Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="gc-you-hua">gc优化</span><a href="#gc-you-hua" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc TLMutator</p>
<hr>
<p>[RC]Avoid acquire TLMutator before real inc/decref<br>For example, IncRef doesn’t need TLMutator</p>
<p>DecRef need mutator, if object is on heap.</p>
<p>This can improve performance and avoid too early IncRef before Intitialize muators.</p>
<p>总之就是在cinterface的MRT_DecRef里干掉TLMutator</p>
<p>什么Mutator？</p>
<p>Mutator是gc的具体实现的抽象</p>
<p>Mutator的子类如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mutator</span><br><span class="line"></span><br><span class="line">RCMutator--&gt;Mutator</span><br><span class="line"></span><br><span class="line">DeferralRCMutator--&gt;RCMutator</span><br><span class="line"></span><br><span class="line">NaiveRCMutator--&gt;RCMutator</span><br><span class="line"></span><br><span class="line">TracingMutator--&gt;Mutator</span><br><span class="line"></span><br><span class="line">ConMarkSweepMutator--&gt;TracingMutator</span><br><span class="line"></span><br><span class="line">MarkSweepMutator(MarkSweepMutator)--&gt;TracingMutator</span><br></pre></td></tr></table></figure>
<p>TLMutator就是NaiveRCMutator</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/gc优化/" data-id="cjqnxtosw000s0307xhr1wq31" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rc/对象的释放过程" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/对象的释放过程/" class="article-date">
  <time datetime="2019-01-08T15:38:07.476Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="dui-xiang-de-shi-fang-guo-cheng">对象的释放过程</span><a href="#dui-xiang-de-shi-fang-guo-cheng" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc</p>
<hr>
<p>释放某个对象,会调用 RosAllocImpl::FreeObj方法,我们从此方法看起</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RosAllocImpl::FreeObj(<span class="keyword">address_t</span> obj_addr) &#123;</span><br><span class="line">  <span class="comment">// release monitor</span></span><br><span class="line">  <span class="comment">//__MRT_ASSERT(!hasWeakProxy(obj_addr), "unexpected");</span></span><br><span class="line">  maplert::Allocator::ReleaseResource(obj_addr);</span><br><span class="line"></span><br><span class="line">  MRT_LOG(ALLOC, LVL_DEBUG, <span class="string">"Freeing object %p"</span>, (<span class="keyword">void</span>* )obj_addr);</span><br><span class="line">  <span class="keyword">size_t</span> obj_size = PreObjFree(obj_addr);</span><br><span class="line">  <span class="keyword">size_t</span> freed_bytes = <span class="number">0U</span>;</span><br><span class="line">  <span class="comment">// 主要释放操作在这里,这是一个宏:</span></span><br><span class="line">  <span class="comment">// #define JSAN_Free(obj, real_free_func, internal_size)internal_size = real_free_func(obj) </span></span><br><span class="line">  <span class="comment">// 调用FreeObjInternal方法释放对象非</span></span><br><span class="line">  JSAN_Free(obj_addr, FreeObjInternal, freed_bytes);</span><br><span class="line">  PostObjFree(freed_bytes, obj_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> RosAllocImpl::FreeObjInternal(<span class="keyword">address_t</span> obj_addr) &#123;</span><br><span class="line">  ROSIMPL_LOG_FREE_OBJ(obj_addr);</span><br><span class="line">  <span class="keyword">size_t</span> internal_size = <span class="number">0U</span>;</span><br><span class="line">  <span class="keyword">uintptr_t</span> page_addr = <span class="number">0U</span>;</span><br><span class="line">  RunSlots* run_slots = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">uint8_t</span> page_type;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// lock_guard&lt;mutex&gt; guard(global_lock_);</span></span><br><span class="line">    page_type = page_map_.GetPageTypeForAddr(obj_addr);</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(LIKELY(page_type == kPRun)) &#123;</span><br><span class="line">      page_addr = ((<span class="keyword">uintptr_t</span>) obj_addr) &amp; (~((<span class="keyword">uintptr_t</span>) <span class="number">0xFFF</span>U));</span><br><span class="line">      run_slots = <span class="keyword">reinterpret_cast</span>&lt;RunSlots*&gt;(page_addr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(LIKELY(page_type == kPLargeObj)) &#123;</span><br><span class="line">      FreeLargeObj(obj_addr, &amp;internal_size);</span><br><span class="line">      <span class="keyword">return</span> internal_size;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page_type == kPRunRem) &#123;</span><br><span class="line">      <span class="comment">// lock_guard&lt;mutex&gt; guard(global_lock_);</span></span><br><span class="line">      page_addr = page_map_.GetRunStartFromAddr(obj_addr);</span><br><span class="line">      run_slots = <span class="keyword">reinterpret_cast</span>&lt;RunSlots*&gt;(page_addr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      MRT_LOG(ALLOC, LVL_ERROR,</span><br><span class="line">          <span class="string">"invalid object address inside FreeObjInternal.  "</span> <span class="string">"obj_address: %p, page_type: %"</span> PRIu8 <span class="string">"\n"</span>,</span><br><span class="line">          (<span class="keyword">void</span>* )obj_addr, page_type);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0U</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ROSIMPL_ASSERT(run_slots != <span class="literal">nullptr</span>, <span class="string">"runslots cannot be null in FreeObjInternal"</span>);</span><br><span class="line">  ROSIMPL_VERIFY_MAGIC_RUN(run_slots);</span><br><span class="line">  internal_size = run_slots-&gt;GetRunSize();</span><br><span class="line">  <span class="keyword">address_t</span> mem_addr = ROSIMPL_GET_ADDR_FROM_OBJ(obj_addr);</span><br><span class="line">  ROSIMPL_HPROF_FREE_RUN(run_slots-&gt;size_idx_, obj_addr);</span><br><span class="line">  (<span class="keyword">void</span>)memset_s((<span class="keyword">void</span>*)mem_addr,  internal_size, <span class="number">0</span>, internal_size);</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(run_slots-&gt;size_idx_ &gt; kMaxTLocalIdx)) &#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; guard(runLocks[run_slots-&gt;size_idx_]);</span><br><span class="line">    FreeObjFromRun(run_slots, obj_addr);</span><br><span class="line">    <span class="keyword">return</span> internal_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> need_update_global = <span class="literal">false</span>;</span><br><span class="line">  &#123;</span><br><span class="line">     lock_guard&lt;mutex&gt; guard(runLocks[run_slots-&gt;size_idx_]);</span><br><span class="line">     <span class="comment">//lock_guard&lt;mutex&gt; guard2(run_slots-&gt;slots_lock);</span></span><br><span class="line">     <span class="keyword">if</span> (LIKELY(run_slots-&gt;IsLocal())) &#123;</span><br><span class="line">       <span class="keyword">address_t</span> mem_addr2 = ROSIMPL_GET_ADDR_FROM_OBJ(obj_addr);</span><br><span class="line">       run_slots-&gt;FreeSlotAsBulk(mem_addr2);</span><br><span class="line">       <span class="keyword">return</span> internal_size;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//attention: when RunSlots has only 1 slot. there is a bug. it is not likely to use mutator to allocate that size space.</span></span><br><span class="line">      <span class="comment">//so we just ignore this case now.</span></span><br><span class="line">       <span class="keyword">address_t</span> mem_addr2 = ROSIMPL_GET_ADDR_FROM_OBJ(obj_addr);</span><br><span class="line">       <span class="keyword">bool</span> is_full = run_slots-&gt;IsFull();</span><br><span class="line">       run_slots-&gt;FreeSlot(mem_addr2);</span><br><span class="line">       <span class="keyword">if</span>(is_full) &#123; <span class="comment">// make sure the run_slot is in the non_full_runs</span></span><br><span class="line">         run_slots-&gt;need_full_to_nofull = <span class="literal">true</span>;</span><br><span class="line">	  need_update_global = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(kReleaseFreeRun &amp;&amp; run_slots-&gt;IsCompletelyFree()) &#123;</span><br><span class="line">         run_slots-&gt;need_remove_empty = <span class="literal">true</span>;</span><br><span class="line">         need_update_global = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(need_update_global) &#123;</span><br><span class="line">    lock_guard&lt;mutex&gt; guard(runLocks[run_slots-&gt;size_idx_]);</span><br><span class="line">    UpdateRunSlotsState(run_slots);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> internal_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/对象的释放过程/" data-id="cjqnxtosy000w03076o54yh53" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rc/Maple Rc初始化分析 2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/Maple Rc初始化分析 2/" class="article-date">
  <time datetime="2019-01-08T15:38:07.475Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="maple-rc-chu-shi-hua-fen-xi-2">Maple Rc初始化分析 2</span><a href="#maple-rc-chu-shi-hua-fen-xi-2" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc Rc初始化分析</p>
<hr>
<h1><span id="zhu-yao-fen-xi-cancellablebackuptrace-fang-fa">主要分析CancellableBackupTrace方法</span><a href="#zhu-yao-fen-xi-cancellablebackuptrace-fang-fa" class="header-anchor">#</a></h1><ol>
<li>通过ClearTracingMark清楚mark标志</li>
<li>创建RootSet</li>
<li>使用ScanRoots方法为Root赋值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root[对象的内存是如何分配的] --&gt; RunBackupTracing[RunBackupTracing垃圾清理方法]</span><br><span class="line">RunBackupTracing --&gt; ms.BackupTrace[ms.BackupTrace,ms指的MarkSweep,即标记清除]</span><br><span class="line">ms.BackupTrace --这里暂时只考虑非异步操作--- ScanRoots[ScanRoots,扫描根节点]</span><br><span class="line"></span><br><span class="line">ScanRoots --&quot;\\&quot;--- ScanStaticFieldRoots        </span><br><span class="line">ScanRoots --&quot;\\&quot;--- ScanExternalRoots</span><br><span class="line">ScanRoots --&quot;\\&quot;--- ScanStringRoots</span><br><span class="line">ScanRoots --&gt; ScanReferenceRoots</span><br><span class="line">ScanRoots --&gt; ScanAllocatorRoots</span><br><span class="line">ScanRoots --&gt; ScanClassLoaderRoots</span><br><span class="line">ScanRoots --&gt; ScanAllStacks</span><br><span class="line">ScanRoots --&gt; ScanLocalRefRoots  </span><br><span class="line">ScanRoots --&gt; ScanGlobalRefRoots  </span><br><span class="line">ScanRoots --&gt; ScanThreadExceptionRoots</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>创建WorkStack</li>
<li>把RootSet的元素放入work_stack中</li>
<li>针对work_stack执行DoTransitiveClosure</li>
<li>针对work_stack执行DoResurrection</li>
<li>再次针对work_stack执行DoTransitiveClosure</li>
<li>执行Sweep方法进行释放</li>
<li>UpdateRootSetCapacity更新rootSet</li>
<li>UpdateWorkStackCapacity更新work_stack<br>|1|2<br>|-</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/Maple Rc初始化分析 2/" data-id="cjqnxtost000o03075gi1leeg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rc/Maple Rc对象创建" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/Maple Rc对象创建/" class="article-date">
  <time datetime="2019-01-08T15:38:07.475Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="maple-rc-dui-xiang-chuang-jian">Maple Rc对象创建</span><a href="#maple-rc-dui-xiang-chuang-jian" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj_create[对象创建] --&gt; NewObj[RosAllocImpl::NewObj]</span><br><span class="line">NewObj --&gt; AllocateObjInternal</span><br><span class="line">AllocateObjInternal--&gt; AllocFromRun_</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/Maple Rc对象创建/" data-id="cjqnxtosu000q0307xvq45jyk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rc/python的循环应用回收算法1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/python的循环应用回收算法1/" class="article-date">
  <time datetime="2019-01-08T15:38:07.474Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="python-de-xun-huan-ying-yong-hui-shou-suan-fa-1">python的循环应用回收算法1</span><a href="#python-de-xun-huan-ying-yong-hui-shou-suan-fa-1" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc python的循环应用回收算法</p>
<hr>
<p>Python中的垃圾回收是以引用计数为主，标记-清除和分代收集为辅。引用计数最大缺陷就是循环引用的问题，所以Python采用了辅助方法。</p>
<p>名词标注</p>
<ul>
<li>容器对象：可能被循环引用的对象，比如集合，数组</li>
<li>非容器对象：不可能成为循环引用的，比如字符串，数值。</li>
</ul>
<p>注1：python的循环引用回收一定程度上使用了分代回收，我没有讲到</p>
<hr>
<ol>
<li><p>这是我们的对象关系图，我们首先确定这个是对象关系图有需要回收的循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1]</span><br><span class="line">a--&gt;c[c:1]</span><br><span class="line">c--&gt;d[d:2]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b[b:1]--&gt;e[e:1]</span><br><span class="line">e--&gt;f[f:1]</span><br><span class="line">f--&gt;b</span><br><span class="line"></span><br><span class="line">d--&gt;x[x:2]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
</li>
<li><p>把计数器备份一份，因为执行一份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,1]</span><br><span class="line">c--&gt;d[d:2,2]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b[b:1,1]--&gt;e[e:1,1]</span><br><span class="line">e--&gt;f[f:1,1]</span><br><span class="line">f--&gt;b</span><br><span class="line">d--&gt;x[x:2,2]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对象创建的时候，做一次备份，把对象用双向链表连接起来，做一次备份</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,1]</span><br><span class="line">c--&gt;d[d:2,2]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b[b:1,1]--&gt;e[e:1,1]</span><br><span class="line">e--&gt;f[f:1,1]</span><br><span class="line">f--&gt;b</span><br><span class="line">d--&gt;x[x:2,2]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
<p>然后把备份的计数器都减1，root直接引用的对象除外（如：a）,即除root直接引用的对象，所有对象的备份计数器都是0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,0]</span><br><span class="line">c--&gt;d[d:2,0]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b--&gt;e[e:1,0]</span><br><span class="line">e--&gt;f[f:1,0]</span><br><span class="line">f--&gt;b[1,0]</span><br><span class="line"></span><br><span class="line">d--&gt;x[x:2,0]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure></p>
<p>b,e,f形成循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,0]</span><br><span class="line">c--&gt;d[d:1,0]</span><br><span class="line">d--&gt;a</span><br><span class="line">b[b:1,0]--&gt;e[e:1,0]</span><br><span class="line">e--&gt;f[f:1,0]</span><br><span class="line">f--&gt;b</span><br><span class="line"></span><br><span class="line">d--&gt;x[2,0]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
<p>此时循环引用b,e,f已经与root没有任何引用关系了,理想情况下，执行gc的时候应该释放掉这个循环引用</p>
<p>在对象生成的时候我们把对象连接成链表</p>
<p>我们把引用关系分成两类</p>
<ol>
<li>备份计数器为0并且不可达</li>
<li>可达并且计数器不为0</li>
</ol>
<p>结合上述图标，按照此规则分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">可达并且计数器不为0:</span><br><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,0]</span><br><span class="line">c--&gt;d[d:1,0]</span><br><span class="line">d--&gt;a</span><br><span class="line">备份计数器为0并且不可达:</span><br><span class="line">b[b:1,0]--&gt;e[e:1,0]</span><br><span class="line">e--&gt;f[f:1,0]</span><br><span class="line">f--&gt;b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d--&gt;x[2,0]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/python的循环应用回收算法1/" data-id="cjqnxtosx000u03072m4oea3m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rc/Maple Rc初始化分析 1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/Maple Rc初始化分析 1/" class="article-date">
  <time datetime="2019-01-08T15:38:07.473Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="maple-rc-chu-shi-hua-fen-xi-1">Maple Rc初始化分析 1</span><a href="#maple-rc-chu-shi-hua-fen-xi-1" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc Rc初始化分析</p>
<hr>
<h2><span id="biao-ti">标题</span><a href="#biao-ti" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init[对象的内存是如何分配的] --&gt; root[gc学习大纲]</span><br><span class="line">collocInit[垃圾回收如何记录对象] --&gt; root</span><br><span class="line">free[对象的内存是如何释放] --&gt; root</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个简单的new对象的.java文件</li>
<li>编译成class</li>
<li>使用sdk的dx转换成dex</li>
<li>使用sdk的dexhump工具查看dex文件内容</li>
<li>发现new-instan## 标题 ##ce字节码命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">root --&gt; runtime[runtime]</span><br><span class="line">runtime[runtime] --&gt; GCImpl.init</span><br><span class="line">GCImpl.init --&gt; MRT_GCInitGlobal</span><br><span class="line">MRT_GCInitGlobal --&gt; g_the_allocator.Init</span><br><span class="line">g_the_allocator.Init --&gt; alloc_space_.Init</span><br><span class="line">alloc_space_.Init --&gt; MemMap::MapMemory[MemMap::MapMemory分配堆内存]</span><br><span class="line">g_the_allocator.Init --&gt; page_map_.Init[page_map_.Init初始化pagemap]</span><br><span class="line">page_map_.Init[page_map_.Init初始化pagemap] --&gt; sudo</span><br><span class="line"></span><br><span class="line">MRT_GCInitGlobal --&gt; g_the_collector.Init</span><br><span class="line">g_the_collector.Init --&gt; RCCollector::Init</span><br><span class="line">RCCollector::Init --&gt; sudo</span><br><span class="line"></span><br><span class="line">g_the_collector.Init --&gt; StartThread</span><br><span class="line"></span><br><span class="line">StartThread --&gt; ms.StartThread</span><br><span class="line">StartThread --&gt; backupTracing[开启NaiveRCCollector::BackupTracingThreadEntry线程]</span><br><span class="line"></span><br><span class="line">backupTracing --&gt; NaiveRCCollector.BackupTracingThreadRun</span><br><span class="line"></span><br><span class="line">NaiveRCCollector.BackupTracingThreadRun --&gt; WaitForEvent;</span><br><span class="line"></span><br><span class="line">WaitForEvent --&quot;event == RcCollection || event == FullCollection&quot;--- RunBackupTracing</span><br><span class="line"></span><br><span class="line">RunBackupTracing --&gt; ms.BackupTrace[ms.BackupTrace 执行垃圾清理]</span><br><span class="line"></span><br><span class="line">ms.BackupTrace --&gt; CancellableBackupTrace</span><br><span class="line"></span><br><span class="line">CancellableBackupTrace --&gt; parallel_gc</span><br><span class="line"></span><br><span class="line">parallel_gc --true--&gt; ParallelScanRoots</span><br><span class="line">ParallelScanRoots --&gt; ParallelResurrection</span><br><span class="line">ParallelResurrection--&gt; ParallelTransitiveClosure</span><br><span class="line">ParallelTransitiveClosure --&gt; ParallelSweep</span><br><span class="line">parallel_gc --false--&gt; ScanRoots</span><br><span class="line">ScanRoots--&gt;DoResurrection</span><br><span class="line">DoResurrection--&gt;DoTransitiveClosure</span><br><span class="line">DoTransitiveClosure--&gt;Sweep</span><br><span class="line">Sweep--&gt;g_the_allocator.FreeAllIf</span><br><span class="line">g_the_allocator.FreeAllIf--&gt;FreeObjsFromRun</span><br><span class="line">FreeObjsFromRun--&gt;PreObjFree</span><br><span class="line">PreObjFree--&gt;memset_s[memset_s清0]</span><br><span class="line">memset_s--&gt;FreeSlot[FreeSlot把此对象地址放到空闲链表]</span><br><span class="line">FreeSlot--&gt;PostObjFree[PostObjFree通知]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/Maple Rc初始化分析 1/" data-id="cjqnxtost000n0307izz13bei" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rc/python的循环应用回收算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/python的循环应用回收算法/" class="article-date">
  <time datetime="2019-01-08T15:38:07.473Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="python-de-xun-huan-ying-yong-hui-shou-suan-fa">python的循环应用回收算法</span><a href="#python-de-xun-huan-ying-yong-hui-shou-suan-fa" class="header-anchor">#</a></h1><p>标签（空格分隔）： python的循环应用回收算法 rc</p>
<hr>
<blockquote>
<p>“标记-清除”是为了解决循环引用的问题。可以包含其他对象引用的容器对象（比如：list，set，dict，class，instance）都可能产生循环引用。<br>我们必须承认一个事实，如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。我们必须先将循环引用摘掉，那么这两个对象的有效计数就现身了。假设两个对象为A、B，我们从A出发，因为它有一个对B的引用，则将B的引用计数减1；然后顺着引用达到B，因为B有一个对A的引用，同样将A的引用减1，这样，就完成了循环引用对象间环摘除。<br>但是这样就有一个问题，假设对象A有一个对象引用C，而C没有引用A，如果将C计数引用减1，而最后A并没有被回收，显然，我们错误的将C的引用计数减1，这将导致在未来的某个时刻出现一个对C的悬空引用。这就要求我们必须在A没有被删除的情况下复原C的引用计数，如果采用这样的方案，那么维护引用计数的复杂度将成倍增加。</p>
<p>原理：“标记-清除”采用了更好的做法，我们并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。<br>这个计数副本的唯一作用是寻找root object集合（该集合中的对象是不能被回收的）。当成功寻找到root object集合之后，首先将现在的内存链表一分为二，一条链表中维护root object集合，成为root链表，而另外一条链表中维护剩下的对象，成为unreachable链表。之所以要剖成两个链表，是基于这样的一种考虑：现在的unreachable可能存在被root链表中的对象，直接或间接引用的对象，这些对象是不能被回收的，一旦在标记的过程中，发现这样的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是名副其实的垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。</p>
</blockquote>
<hr>
<ol>
<li>生成链表A</li>
<li>在容器对象创建的时候把容器对象添加到链表A中</li>
<li><p>在释放循环引用容器对象前，有些容器对象可能失去引用关系（count为0），但是在A链表中这个节点还是存在的，那么此时我们需要在A链表中剔除已经释放的容器对象</p>
</li>
<li><p>在分配对象时检测内存空间是否不足，如果不足需要检测A链表中是否存在循环引用容器对象</p>
</li>
<li>把对象的count复制到容器对象的count里，做一个备份<br> 在python里，普通对象和容器对象是两个结构体，换句话说，只有容器对象才需要复制count</li>
<li>通过遍历链表A把所有容器对象的备份count自减1，root对象除外<br> 因为对象的类型是不确定的，是否真的应该自减，比如root对象就不需要自减，比如用户有手动实现容器对象的话，那么也    会与我们的循环引用不兼容。这里python的做法是使用访问者模式，把自减的方法传递给具体容器对象，让具体实现去决定    是否应该执行自减。<strong>精髓</strong></li>
<li>因为链表的head是写死的，我们可以直接访问，其实这个head就是root，</li>
<li>我们直接访问链表的head，如果head是大于0，那么我们就认为这个链表里所有的对象都是可达的。如果root等于0，那么这    个链表的所有对象就是循环引用了，<br> <strong>对比传统的数据结构遍历，此方法的效率，要高的多。</strong></li>
<li>在不可达链表中移除带有终结器的对象。</li>
<li>把不可达链表的所有对象释放掉。<ol>
<li>释放的步骤如下<ol>
<li>自增</li>
<li>释放</li>
<li>自减<br>考虑到循环引用是多个对象相互引用，可能会因为释放操作造成自身清除，所以在count不为0的时候进行释放操作。</li>
</ol>
</li>
<li>对象可能会因为某种原因释放失败，需要把它重新放入到A链表中去。</li>
</ol>
</li>
</ol>
<p>#注：</p>
<ol>
<li><p>终结器，Object类的finalize方法叫做终结器，这种循环引用没办法解决，比如有两个对象，a和b，a的finalize方法访问b，b的finalize方法访问a，先释放哪个都不对。</p>
</li>
<li><p>分代<br> python的实现里是有分代的实现的，这篇文章面向新人，分代不是主线，简单为主。</p>
</li>
</ol>
<p>总结：</p>
<pre><code>1. 复制count，清空count，就是为了分离可达对象和不可达对象
2. python的count的类型使用了ssize_t的类型，该类型在32位环境下是int，在64位环境下是long
    该类型允许为负数，仅仅是为了debug方便。可以把count当做错误信息输出。
</code></pre><blockquote>
<p>官方文档</p>
<p><a href="https://docs.python.org/2/faq/design.html#how-does-python-manage-memory" target="_blank" rel="noopener">https://docs.python.org/2/faq/design.html#how-does-python-manage-memory</a></p>
<p><a href="http://arctrix.com/nas/python/gc/" target="_blank" rel="noopener">http://arctrix.com/nas/python/gc/</a></p>
<p><a href="https://github.com/python/cpython/blob/3.7/Doc/c-api/gcsupport.rst" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.7/Doc/c-api/gcsupport.rst</a></p>
<p>相关文档</p>
<p><a href="http://www.wklken.me/posts/2015/09/29/python-source-gc.html" target="_blank" rel="noopener">http://www.wklken.me/posts/2015/09/29/python-source-gc.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/python的循环应用回收算法/" data-id="cjqnxtosw000t0307uslllrsr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rc/rc的环问题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/rc/rc的环问题/" class="article-date">
  <time datetime="2019-01-08T15:38:07.473Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="rc-de-huan-wen-ti">rc的环问题</span><a href="#rc-de-huan-wen-ti" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc</p>
<hr>
<p>rc的应用<br>引用计数法主要用在 c++ 标准库的 std::shared_ptr 、微软的 COM 、python，Go，Objective-C 和 PHP 中。</p>
<ol>
<li>Mark-Sweep法</li>
<li>三色标记法</li>
<li>分代收集法</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/rc/rc的环问题/" data-id="cjqnxtosx000v0307njih49zp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python的循环应用回收算法/python的循环应用回收算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/python的循环应用回收算法/python的循环应用回收算法/" class="article-date">
  <time datetime="2019-01-08T15:38:07.472Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="python-de-xun-huan-ying-yong-hui-shou-suan-fa">python的循环应用回收算法</span><a href="#python-de-xun-huan-ying-yong-hui-shou-suan-fa" class="header-anchor">#</a></h1><p>标签（空格分隔）： python的循环应用回收算法 rc</p>
<hr>
<blockquote>
<p>“标记-清除”是为了解决循环引用的问题。可以包含其他对象引用的容器对象（比如：list，set，dict，class，instance）都可能产生循环引用。<br>我们必须承认一个事实，如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。我们必须先将循环引用摘掉，那么这两个对象的有效计数就现身了。假设两个对象为A、B，我们从A出发，因为它有一个对B的引用，则将B的引用计数减1；然后顺着引用达到B，因为B有一个对A的引用，同样将A的引用减1，这样，就完成了循环引用对象间环摘除。<br>但是这样就有一个问题，假设对象A有一个对象引用C，而C没有引用A，如果将C计数引用减1，而最后A并没有被回收，显然，我们错误的将C的引用计数减1，这将导致在未来的某个时刻出现一个对C的悬空引用。这就要求我们必须在A没有被删除的情况下复原C的引用计数，如果采用这样的方案，那么维护引用计数的复杂度将成倍增加。</p>
<p>原理：“标记-清除”采用了更好的做法，我们并不改动真实的引用计数，而是将集合中对象的引用计数复制一份副本，改动该对象引用的副本。对于副本做任何的改动，都不会影响到对象生命走起的维护。<br>这个计数副本的唯一作用是寻找root object集合（该集合中的对象是不能被回收的）。当成功寻找到root object集合之后，首先将现在的内存链表一分为二，一条链表中维护root object集合，成为root链表，而另外一条链表中维护剩下的对象，成为unreachable链表。之所以要剖成两个链表，是基于这样的一种考虑：现在的unreachable可能存在被root链表中的对象，直接或间接引用的对象，这些对象是不能被回收的，一旦在标记的过程中，发现这样的对象，就将其从unreachable链表中移到root链表中；当完成标记后，unreachable链表中剩下的所有对象就是名副其实的垃圾对象了，接下来的垃圾回收只需限制在unreachable链表中即可。</p>
</blockquote>
<hr>
<ol>
<li>生成链表A</li>
<li>在容器对象创建的时候把容器对象添加到链表A中</li>
<li><p>在释放循环引用容器对象前，有些容器对象可能失去引用关系（count为0），但是在A链表中这个节点还是存在的，那么此时我们需要在A链表中剔除已经释放的容器对象</p>
</li>
<li><p>在分配对象时检测内存空间是否不足，如果不足需要检测A链表中是否存在循环引用容器对象</p>
</li>
<li>把对象的count复制到容器对象的count里，做一个备份<br> 在python里，普通对象和容器对象是两个结构体，换句话说，只有容器对象才需要复制count</li>
<li>通过遍历链表A把所有容器对象的备份count自减1，root对象除外<br> 因为对象的类型是不确定的，是否真的应该自减，比如root对象就不需要自减，比如用户有手动实现容器对象的话，那么也    会与我们的循环引用不兼容。这里python的做法是使用访问者模式，把自减的方法传递给具体容器对象，让具体实现去决定    是否应该执行自减。<strong>精髓</strong></li>
<li>因为链表的head是写死的，我们可以直接访问，其实这个head就是root，</li>
<li>我们直接访问链表的head，如果head是大于0，那么我们就认为这个链表里所有的对象都是可达的。如果root等于0，那么这    个链表的所有对象就是循环引用了，<br> <strong>对比传统的数据结构遍历，此方法的效率，要高的多。</strong></li>
<li>在不可达链表中移除带有终结器的对象。</li>
<li>把不可达链表的所有对象释放掉。<ol>
<li>释放的步骤如下<ol>
<li>自增</li>
<li>释放</li>
<li>自减<br>考虑到循环引用是多个对象相互引用，可能会因为释放操作造成自身清除，所以在count不为0的时候进行释放操作。</li>
</ol>
</li>
<li>对象可能会因为某种原因释放失败，需要把它重新放入到A链表中去。</li>
</ol>
</li>
</ol>
<p>#注：</p>
<ol>
<li><p>终结器，Object类的finalize方法叫做终结器，这种循环引用没办法解决，比如有两个对象，a和b，a的finalize方法访问b，b的finalize方法访问a，先释放哪个都不对。</p>
</li>
<li><p>分代<br> python的实现里是有分代的实现的，这篇文章面向新人，分代不是主线，简单为主。</p>
</li>
</ol>
<p>总结：</p>
<pre><code>1. 复制count，清空count，就是为了分离可达对象和不可达对象
2. python的count的类型使用了ssize_t的类型，该类型在32位环境下是int，在64位环境下是long
    该类型允许为负数，仅仅是为了debug方便。可以把count当做错误信息输出。
</code></pre><blockquote>
<p>官方文档</p>
<p><a href="https://docs.python.org/2/faq/design.html#how-does-python-manage-memory" target="_blank" rel="noopener">https://docs.python.org/2/faq/design.html#how-does-python-manage-memory</a></p>
<p><a href="http://arctrix.com/nas/python/gc/" target="_blank" rel="noopener">http://arctrix.com/nas/python/gc/</a></p>
<p><a href="https://github.com/python/cpython/blob/3.7/Doc/c-api/gcsupport.rst" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.7/Doc/c-api/gcsupport.rst</a></p>
<p>相关文档</p>
<p><a href="http://www.wklken.me/posts/2015/09/29/python-source-gc.html" target="_blank" rel="noopener">http://www.wklken.me/posts/2015/09/29/python-source-gc.html</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/python的循环应用回收算法/python的循环应用回收算法/" data-id="cjqnxtosr000k0307n5w8m48o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python的循环应用回收算法/python的循环应用回收算法1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/08/python的循环应用回收算法/python的循环应用回收算法1/" class="article-date">
  <time datetime="2019-01-08T15:38:07.472Z" itemprop="datePublished">2019-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1><span id="python-de-xun-huan-ying-yong-hui-shou-suan-fa-1">python的循环应用回收算法1</span><a href="#python-de-xun-huan-ying-yong-hui-shou-suan-fa-1" class="header-anchor">#</a></h1><p>标签（空格分隔）： rc python的循环应用回收算法</p>
<hr>
<p>Python中的垃圾回收是以引用计数为主，标记-清除和分代收集为辅。引用计数最大缺陷就是循环引用的问题，所以Python采用了辅助方法。</p>
<p>名词标注</p>
<ul>
<li>容器对象：可能被循环引用的对象，比如集合，数组</li>
<li>非容器对象：不可能成为循环引用的，比如字符串，数值。</li>
</ul>
<p>注1：python的循环引用回收一定程度上使用了分代回收，我没有讲到</p>
<hr>
<ol>
<li><p>这是我们的对象关系图，我们首先确定这个是对象关系图有需要回收的循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1]</span><br><span class="line">a--&gt;c[c:1]</span><br><span class="line">c--&gt;d[d:2]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b[b:1]--&gt;e[e:1]</span><br><span class="line">e--&gt;f[f:1]</span><br><span class="line">f--&gt;b</span><br><span class="line"></span><br><span class="line">d--&gt;x[x:2]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
</li>
<li><p>把计数器备份一份，因为执行一份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,1]</span><br><span class="line">c--&gt;d[d:2,2]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b[b:1,1]--&gt;e[e:1,1]</span><br><span class="line">e--&gt;f[f:1,1]</span><br><span class="line">f--&gt;b</span><br><span class="line">d--&gt;x[x:2,2]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对象创建的时候，做一次备份，把对象用双向链表连接起来，做一次备份</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,1]</span><br><span class="line">c--&gt;d[d:2,2]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b[b:1,1]--&gt;e[e:1,1]</span><br><span class="line">e--&gt;f[f:1,1]</span><br><span class="line">f--&gt;b</span><br><span class="line">d--&gt;x[x:2,2]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
<p>然后把备份的计数器都减1，root直接引用的对象除外（如：a）,即除root直接引用的对象，所有对象的备份计数器都是0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,0]</span><br><span class="line">c--&gt;d[d:2,0]</span><br><span class="line">a--&gt;d</span><br><span class="line"></span><br><span class="line">b--&gt;e[e:1,0]</span><br><span class="line">e--&gt;f[f:1,0]</span><br><span class="line">f--&gt;b[1,0]</span><br><span class="line"></span><br><span class="line">d--&gt;x[x:2,0]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure></p>
<p>b,e,f形成循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,0]</span><br><span class="line">c--&gt;d[d:1,0]</span><br><span class="line">d--&gt;a</span><br><span class="line">b[b:1,0]--&gt;e[e:1,0]</span><br><span class="line">e--&gt;f[f:1,0]</span><br><span class="line">f--&gt;b</span><br><span class="line"></span><br><span class="line">d--&gt;x[2,0]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure>
<p>此时循环引用b,e,f已经与root没有任何引用关系了,理想情况下，执行gc的时候应该释放掉这个循环引用</p>
<p>在对象生成的时候我们把对象连接成链表</p>
<p>我们把引用关系分成两类</p>
<ol>
<li>备份计数器为0并且不可达</li>
<li>可达并且计数器不为0</li>
</ol>
<p>结合上述图标，按照此规则分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">可达并且计数器不为0:</span><br><span class="line">root--&gt;a[a:1,1]</span><br><span class="line">a--&gt;c[c:1,0]</span><br><span class="line">c--&gt;d[d:1,0]</span><br><span class="line">d--&gt;a</span><br><span class="line">备份计数器为0并且不可达:</span><br><span class="line">b[b:1,0]--&gt;e[e:1,0]</span><br><span class="line">e--&gt;f[f:1,0]</span><br><span class="line">f--&gt;b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d--&gt;x[2,0]</span><br><span class="line">f--&gt;x</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/08/python的循环应用回收算法/python的循环应用回收算法1/" data-id="cjqnxtosr000l03076eplrmtf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/08/未分类/Prt 项目记录/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/08/未分类/java解释器分析/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/08/未分类/Tracing Gc/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/08/收藏/博客收藏/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/01/08/vcs/maple的repo/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>